<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ECC 椭圆曲线加密</title>
    <style>
        :root {
            color-scheme: light;
            --surface: #ffffff;
            --background: #f5f6fb;
            --border: #dcdff0;
            --border-strong: #b7bdde;
            --text-primary: #1f1f2c;
            --text-muted: #5b5f78;
            --accent: #3a72ff;
            --accent-soft: rgba(58, 91, 255, .1);
            --radius-lg: 6px;
            --radius-md: 4px;
            --shadow-soft: 0 4px 10px rgba(25, 35, 80, .08);
            --surface-alpha: rgba(255, 255, 255, .6);
            --surface-alpha-strong: rgba(255, 255, 255, .8);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                color-scheme: dark;
                --surface: #2d313c;
                --background: #20242B;
                --border: #2a2d3a;
                --border-strong: #777c949b;
                --text-primary: #e8eaf0;
                --text-muted: #d9deec;
                --accent: #5b8dff;
                --accent-soft: rgba(91, 141, 255, .15);
                --shadow-soft: 0 8px 24px rgba(0, 0, 0, .4);
                --surface-alpha: rgba(32, 36, 43, .8);
                --surface-alpha-strong: rgba(32, 36, 43, .9);
            }
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            min-height: 100vh;
            user-select: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .app-shell {
            max-width: 960px;
            margin: 60px auto;
            padding: 0 32px 80px;
            display: flex;
            flex-direction: column;
            gap: 28px;
        }

        .hero {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 24px;
            box-shadow: var(--shadow-soft);
        }

        .hero h1 {
            margin: 0 0 10px;
            font-size: 32px;
            font-weight: 600;
        }

        .hero p {
            margin: 0;
            color: var(--text-muted);
            line-height: 1.6;
        }

        .encoding-selector {
            display: flex;
            border: 1px solid var(--border);
            border-radius: 999px;
            background: var(--surface-alpha);
            padding: 4px;
            gap: 4px;
        }

        .encoding-btn {
            background: transparent;
            border-radius: 999px;
            border: 1px solid transparent;
            padding: 6px 16px;
            font-size: 13px;
            color: var(--text-muted);
            white-space: nowrap;
            transition: all .2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .encoding-btn.active {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent);
            box-shadow: 0 4px 12px rgba(58, 91, 255, .2);
        }

        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 28px;
            display: flex;
            flex-direction: column;
            gap: 24px;
            box-shadow: var(--shadow-soft);
        }

        section .card {
            margin-bottom: 24px;
        }

        .key-card {
            gap: 32px;
        }

        .card-head {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: space-between;
            align-items: center;
        }

        .card-head h2 {
            margin: 0;
            font-size: 22px;
            font-weight: 600;
        }

        .hint {
            margin: 0;
            color: var(--text-muted);
            font-size: 14px;
        }

        .actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .inline {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: var(--text-muted);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 24px;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-muted);
        }

        textarea {
            width: 100%;
            min-height: 120px;
            padding: 14px 16px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--surface-alpha);
            font-size: 15px;
            line-height: 1.6;
            color: var(--text-primary);
            resize: vertical;
            transition: border-color .2s ease, box-shadow .2s ease;
            -webkit-appearance: none;
            appearance: none;
            font-family: inherit;
        }

        textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-soft);
        }

        .private-key-field.blurred {
            filter: blur(8px);
            user-select: none;
            pointer-events: none;
        }

        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        button {
            border: 1.5px solid transparent;
            border-radius: 6px;
            padding: 5px 14px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all .2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .primary {
            background: var(--accent);
            color: #fff;
        }

        .ghost {
            background: transparent;
            border-color: var(--border-strong);
            color: var(--text-muted);
        }

        .ghost:hover,
        .ghost:focus {
            border-color: var(--accent);
            color: var(--accent);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .tab-bar {
            display: inline-flex;
            border: 1px solid var(--border);
            border-radius: 999px;
            background: var(--surface-alpha-strong);
            padding: 6px;
            gap: 6px;
            align-self: center;
            box-shadow: var(--shadow-soft);
        }

        .tab-btn {
            background: transparent;
            border-radius: 999px;
            border: 1px solid transparent;
            padding: 8px 28px;
            font-size: 15px;
            color: var(--text-muted);
            transition: all .2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .tab-btn.active {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent);
            box-shadow: 0 8px 18px rgba(58, 91, 255, .25);
        }

        .panel {
            display: none;
        }

        .panel.active {
            display: block;
        }

        @media (max-width: 768px) {
            .app-shell {
                padding: 0 16px 40px;
                margin: 24px auto;
                gap: 20px;
            }

            .hero {
                padding: 20px;
                flex-direction: column;
                align-items: stretch;
                gap: 16px;
            }

            .hero h1 {
                font-size: 24px;
                margin-bottom: 8px;
            }

            .hero p {
                font-size: 14px;
            }

            .encoding-selector {
                justify-content: center;
                flex-wrap: wrap;
            }

            .encoding-btn {
                padding: 8px 14px;
                font-size: 14px;
            }

            .tab-bar {
                align-self: stretch;
                justify-content: center;
            }

            .tab-btn {
                flex: 1;
                padding: 10px 16px;
                font-size: 14px;
            }

            .card {
                padding: 20px;
                gap: 20px;
            }

            .card-head {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .card-head h2 {
                font-size: 18px;
            }

            .hint {
                font-size: 13px;
            }

            .grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            textarea {
                min-height: 100px;
                font-size: 14px;
                padding: 12px;
            }

            .button-row {
                width: 100%;
            }

            button {
                padding: 12px 18px;
                font-size: 14px;
                flex: 1;
                min-width: 0;
            }

            .actions {
                width: 100%;
            }

            .inline {
                font-size: 13px;
            }

            label {
                font-size: 13px;
            }
        }

        @media (max-width: 480px) {
            .app-shell {
                padding: 0 12px 30px;
                margin: 16px auto;
                gap: 16px;
            }

            .hero {
                padding: 16px;
            }

            .hero h1 {
                font-size: 20px;
            }

            .hero p {
                font-size: 13px;
                line-height: 1.5;
            }

            .card {
                padding: 16px;
                gap: 16px;
            }

            .card-head h2 {
                font-size: 16px;
            }

            textarea {
                min-height: 80px;
                font-size: 13px;
            }

            .button-row {
                flex-direction: column;
            }

            button {
                width: 100%;
                padding: 12px;
            }
        }
    </style>
</head>

<body>
    <div class="app-shell">
        <header class="hero">
            <div>
                <h1>ECC 椭圆曲线加密</h1>
                <p>使用 Web Crypto API 进行本地加解密，密钥对使用 Passkey 本地加密保存</p>
            </div>
            <div class="encoding-selector">
                <button class="encoding-btn" data-encoding="base64">Base64</button>
                <button class="encoding-btn" data-encoding="hex">十六进制</button>
                <button class="encoding-btn active" data-encoding="hajimi">哈基米</button>
            </div>
        </header>

        <nav class="tab-bar" aria-label="模式切换">
            <button class="tab-btn active" data-target="sendPanel">发送信息</button>
            <button class="tab-btn" data-target="receivePanel">接收信息</button>
        </nav>

        <section id="sendPanel" class="panel active">
            <div class="card">
                <div class="card-head">
                    <h2>加密消息</h2>
                    <p class="hint">粘贴对方给的公钥，然后输入想加密的消息。</p>
                </div>
                <div class="field">
                    <label for="peerPublicKey">公钥</label>
                    <textarea id="peerPublicKey" placeholder="粘贴对方提供的公钥"></textarea>
                    <div class="button-row">
                        <button class="ghost" onclick="pasteText('peerPublicKey')">粘贴</button>
                    </div>
                </div>
                <div class="field">
                    <label for="plaintext">明文</label>
                    <textarea id="plaintext" placeholder="输入要发送的消息"></textarea>
                    <div class="button-row">
                        <button class="primary" onclick="encryptMessage()">加密消息</button>
                    </div>
                </div>
                <div class="field">
                    <label for="encryptedResult">加密结果（密文）</label>
                    <textarea id="encryptedResult" readonly></textarea>
                    <div class="button-row">
                        <button class="ghost" onclick="copyText('encryptedResult')">复制</button>
                    </div>
                </div>
            </div>
        </section>

        <section id="receivePanel" class="panel">
            <div class="card">
                <div class="card-head">
                    <h2>生成密钥对</h2>
                    <div class="actions">
                        <label class="inline">
                            <input type="checkbox" id="showPrivateKey" onclick="renderCryptoKey()"> 显示私钥
                        </label>
                    </div>
                </div>
                <div class="grid">
                    <div class="field">
                        <label for="myPublicKey">公钥</label>
                        <textarea id="myPublicKey" readonly></textarea>
                        <div class="button-row">
                            <button class="primary" onclick="generateKeyPair()">生成新密钥</button>
                            <button class="ghost" onclick="copyText('myPublicKey')">复制</button>
                        </div>
                    </div>
                    <div class="field">
                        <label for="myPrivateKey">私钥</label>
                        <textarea id="myPrivateKey" readonly class="private-key-field"></textarea>
                        <div class="button-row">
                            <button id="copyPrivateKeyBtn" class="ghost" onclick="copyText('myPrivateKey')"
                                disabled>复制</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="card">
                <div class="card-head">
                    <h2>解密消息</h2>
                    <p class="hint"></p>
                </div>
                <div class="field">
                    <label for="ciphertext">密文</label>
                    <textarea id="ciphertext"></textarea>
                    <div class="button-row">
                        <button class="primary" onclick="decryptMessage()">解密消息</button>
                        <button class="ghost" onclick="pasteText('ciphertext')">粘贴并解密</button>
                    </div>
                </div>
                <div class="field">
                    <label for="decryptedResult">解密结果（明文）</label>
                    <textarea id="decryptedResult" readonly></textarea>
                    <div class="button-row">
                        <button class="ghost" onclick="copyText('decryptedResult')">复制</button>
                    </div>
                </div>
            </div>
        </section>
    </div>
    <script>
        const $ = id => document.getElementById(id)

        let currentEncoding = 'hajimi'

        // Type 1: Base64
        const base64Encoding = {
            arrayBufferToText: buffer => btoa(String.fromCharCode(...new Uint8Array(buffer))),
            textToArrayBuffer: base64 => {
                const binaryString = atob(base64)
                const bytes = new Uint8Array(binaryString.length)
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i)
                }
                return bytes.buffer
            },
            delimiter: '|'
        }

        // Type 2: Hexadecimal
        const hexEncoding = {
            arrayBufferToText: buffer => Array.from(new Uint8Array(buffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join(''),
            textToArrayBuffer: text => {
                const matches = text.match(/[0-9a-f]{2}/gi)
                if (!matches) throw new Error('Invalid hex format')
                return new Uint8Array(matches.map(byte => parseInt(byte, 16))).buffer
            },
            delimiter: 'x'
        }

        // Type 3: Dictionary
        const dict = '哈 基 米 曼波 奶龙 阿西噶 哈压库 老爷爷 踩背 楼上 叮咚鸡 大狗叫 一段 带一段 南北 绿豆'.split(' ').sort((a, b) => a.length - b.length)
        const dictEncoding = {
            arrayBufferToText: buffer => {
                const bytes = new Uint8Array(buffer).reduce((a, b) => [...a, b >> 4 & 15, b & 15], [])
                if (!bytes?.length) return ''

                let counts = new Array(16).fill(0).map((_, i) => [0, i])
                bytes.forEach(b => counts[b][0]++)
                counts.sort((a, b) => b[0] - a[0])

                const sortedDict = []
                counts.forEach(([, rank], i) => sortedDict[rank] = dict[i])

                return sortedDict.join('') + bytes.map(b => sortedDict[b]).join('')
            },
            textToArrayBuffer: text => {
                if (!text?.length) return new ArrayBuffer(0)

                let ptr = 0
                const sortedDict = []

                const nextToken = (word) => text.startsWith(word, ptr) && !(word === '哈' && text.startsWith('哈压库', ptr))

                for (let i = 0; i < 16; i++) {
                    const key = dict.filter(word => !sortedDict.includes(word)).find(nextToken)
                    if (!key) throw new Error('Dictionary parse error')
                    sortedDict.push(key)
                    ptr += key.length
                }
                if (sortedDict.length !== dict.length) throw new Error('Dictionary parse error')

                const bytes = []
                while (ptr < text.length) {
                    const highbit = sortedDict.findIndex(nextToken)
                    if (highbit === -1) throw new Error('Text parse error')
                    ptr += sortedDict[highbit].length

                    const lowbit = sortedDict.findIndex(nextToken)
                    if (lowbit === -1) throw new Error('Text parse error')
                    ptr += sortedDict[lowbit].length

                    bytes.push((highbit << 4) | lowbit)
                }
                return new Uint8Array(bytes).buffer
            },
            delimiter: '，'
        }

        const encodings = {
            base64: base64Encoding,
            hex: hexEncoding,
            hajimi: dictEncoding
        }

        const getEncoding = () => encodings[currentEncoding]
        const setEncoding = encoding => {
            currentEncoding = encoding
            renderCryptoKey()

            const buttons = document.querySelectorAll('.encoding-btn')
            buttons.forEach(b => b.classList.toggle('active', b.dataset.encoding === encoding))
        }

        const arrayBufferToText = buffer => getEncoding().arrayBufferToText(buffer)
        const textToArrayBuffer = text => getEncoding().textToArrayBuffer(text)
        const getDelimiter = () => getEncoding().delimiter

        const copyText = async id => {
            const element = document.getElementById(id)
            const text = element.value
            if (!text) return

            try {
                await navigator.clipboard.writeText(text)
                return
            } catch (err) {
                element.select()
                element.setSelectionRange(0, text.length)
                document.execCommand('copy')
            }
        }

        const pasteText = async id => {
            const element = document.getElementById(id)
            if (!element) return

            try {
                const text = await navigator.clipboard.readText()
                element.value = text

                // 如果是密文字段，自动触发解密
                if (id === 'ciphertext' && text.trim()) {
                    await decryptMessage()
                }
            } catch (err) {
                console.warn('剪贴板读取失败，请手动粘贴', err)
                alert('无法自动粘贴，请使用 Ctrl+V 手动粘贴')
                element.focus()
            }
        }

        let myPublicKey = null
        let myPrivateKey = null

        const generateRandomMask = (length = 400) => {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
            return new Uint8Array(length).map(() => chars.charCodeAt(Math.floor(Math.random() * chars.length))).buffer
        }

        const renderCryptoKey = () => {
            $('myPublicKey').value = arrayBufferToText(myPublicKey)

            const shouldShow = $('showPrivateKey').checked
            const field = $('myPrivateKey')
            const copyBtn = $('copyPrivateKeyBtn')

            if (shouldShow) {
                field.value = arrayBufferToText(myPrivateKey)
                field.classList.remove('blurred')
                copyBtn.disabled = false
            } else if (myPrivateKey !== null) {
                field.value = arrayBufferToText(generateRandomMask())
                field.classList.add('blurred')
                copyBtn.disabled = true
            } else {
                field.value = ''
                field.classList.remove('blurred')
                copyBtn.disabled = true
            }
        }

        async function generateKeyPair() {
            try {
                const key = await crypto.subtle.generateKey(
                    { name: 'ECDH', namedCurve: 'P-384' },
                    true,
                    ['deriveKey']
                )

                myPublicKey = await crypto.subtle.exportKey('spki', key.publicKey)
                myPrivateKey = await crypto.subtle.exportKey('pkcs8', key.privateKey)

                renderCryptoKey()
            } catch (err) {
                console.error('密钥生成错误:', err)
                alert('密钥生成失败，请检查控制台')
            }
        }

        async function encryptMessage() {
            const publicKey = $('peerPublicKey').value
            const plaintext = $('plaintext').value

            if (!publicKey) {
                alert('请输入对方公钥')
                return
            }

            try {
                const words = publicKey.split('')
                if (words.every(c => "0123456789abcdef".includes(c))) {
                    setEncoding('hex')
                } else if (words.includes("=") || words.includes("/") || words.includes("+")) {
                    setEncoding('base64')
                } else if (words.includes("哈") || words.includes("基") || words.includes("米")) {
                    setEncoding('hajimi')
                }

                const peerPublicKey = await crypto.subtle.importKey(
                    'spki',
                    textToArrayBuffer(publicKey),
                    { name: 'ECDH', namedCurve: 'P-384' },
                    true,
                    []
                )
                const ephemeralKeyPair = await crypto.subtle.generateKey(
                    { name: 'ECDH', namedCurve: 'P-384' },
                    true,
                    ['deriveKey']
                )
                const sharedKey = await crypto.subtle.deriveKey(
                    { name: 'ECDH', public: peerPublicKey },
                    ephemeralKeyPair.privateKey,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt']
                )
                const iv = crypto.getRandomValues(new Uint8Array(12))
                const encoder = new TextEncoder()
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv },
                    sharedKey,
                    encoder.encode(plaintext)
                )
                const ephemeralPublicKey = await crypto.subtle.exportKey(
                    'spki',
                    ephemeralKeyPair.publicKey
                )

                $('encryptedResult').value = [iv, encrypted, ephemeralPublicKey].map(arrayBufferToText).join(getDelimiter())
            } catch (err) {
                console.error('加密失败:', err)
                alert('加密失败，请检查公钥格式')
            }
        }
        async function decryptMessage() {
            const ciphertextJson = $('ciphertext').value

            if (!ciphertextJson || !myPrivateKey) return

            try {
                const prevEncoding = currentEncoding
                const words = ciphertextJson.split('')
                if (words.every(c => "0123456789abcdef".includes(c))) {
                    setEncoding('hex')
                } else if (words.includes("=") || words.includes("/") || words.includes("+")) {
                    setEncoding('base64')
                } else if (words.includes("哈") || words.includes("基") || words.includes("米")) {
                    setEncoding('hajimi')
                }

                const data = ciphertextJson.split(getDelimiter()).map(text => text.trim()).filter(Boolean)
                const ephemeralPublicKey = await crypto.subtle.importKey(
                    'spki',
                    textToArrayBuffer(data[2]),
                    { name: 'ECDH', namedCurve: 'P-384' },
                    true,
                    []
                )
                const privateKey = await crypto.subtle.importKey(
                    'pkcs8',
                    myPrivateKey,
                    { name: 'ECDH', namedCurve: 'P-384' },
                    true,
                    ['deriveKey']
                )
                const sharedKey = await crypto.subtle.deriveKey(
                    { name: 'ECDH', public: ephemeralPublicKey },
                    privateKey,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['decrypt']
                )

                setEncoding(prevEncoding)
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: textToArrayBuffer(data[0]) },
                    sharedKey,
                    textToArrayBuffer(data[1])
                )
                $('decryptedResult').value = new TextDecoder().decode(decrypted)
            } catch (err) {
                console.error('解密失败:', err)
                alert('解密失败，请检查数据格式')
            }
        }

        const initTabs = () => {
            const buttons = document.querySelectorAll('.tab-btn')
            const panels = document.querySelectorAll('.panel')

            buttons.forEach(btn => {
                btn.addEventListener('click', async () => {
                    const target = btn.dataset.target
                    buttons.forEach(b => b.classList.toggle('active', b === btn))
                    panels.forEach(panel => {
                        panel.classList.toggle('active', panel.id === target)
                    })
                })
            })
        }

        const initEncodingSelector = () => {
            const buttons = document.querySelectorAll('.encoding-btn')
            buttons.forEach(btn => {
                btn.addEventListener('click', () => setEncoding(btn.dataset.encoding))
            })
        }

        initTabs()
        initEncodingSelector()
    </script>
</body>

</html>